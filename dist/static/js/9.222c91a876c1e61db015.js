webpackJsonp([9],{L2R0:function(t,e,v){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var _={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticStyle:{width:"60%",margin:"auto"}},[_("div",[_("h1",[t._v("CSRF")]),t._v(" "),_("p",[t._v("CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。")])]),t._v(" "),_("div",[_("h2",[t._v("CSRF原理")]),t._v(" "),_("img",{staticStyle:{width:"100%"},attrs:{src:v("yZa2")}}),t._v(" "),_("p",[t._v("一次CSRF攻击，受害者必须依次完毕两个步骤： 登录受信任站点A，并在本地生成Cookie。 在不登出A的情况下，訪问危急站点B。")]),t._v(" "),_("h2",[t._v("CSRF攻击类型")]),t._v(" "),_("h3",[t._v("1.GET类型的CSRF")]),t._v(" "),_("p",[t._v("仅仅须要一个HTTP请求。就能够构造一次简单的CSRF。")]),t._v(" "),_("p",[_("b",[t._v("样例：")]),_("br"),t._v(" "),_("b",[t._v("银行站点A： ")]),t._v(" 它以GET请求来完毕银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&money=1000"),_("br"),t._v(" "),_("b",[t._v("危急站点B： ")]),t._v(" 它里面有一段HTML的代码例如以下：img src=http://www.mybank.com/Transfer.php?toBankId=11&money=1000"),_("br"),t._v(" "),_("b",[t._v("后果： ")]),t._v(" 登录了银行站点A--訪问危急站点B==银行账户少了1000块"),_("br"),t._v(" "),_("b",[t._v("原因： ")]),t._v(" 银行站点A违反了HTTP规范，使用GET请求更新资源"),_("br"),t._v(" "),_("b",[t._v("原理： ")]),t._v(" 登录了银行站点A--訪问站点B，浏览器会带上站点A的Cookie发出Get请求，去获取资源以GET的方式请求站点A，站点A收到请求后，觉得这是一个合法更新资源操作\n    ")]),t._v(" "),_("h3",[t._v(" 2、POST类型的CSRF")]),t._v(" "),_("p",[t._v("如图解所示")])]),t._v(" "),_("div",[_("h2",[t._v("防御CSRF")]),t._v("CSRF攻击问题一般是由服务端解决\n    "),_("h3",[t._v("尽量使用POST，限制GET")]),t._v(" "),_("h3",[t._v("将cookie设置为HttpOnly")]),t._v(" "),_("h3",[t._v("提交验证码")]),t._v(" "),_("p",[t._v("在表单中添加一个随机的数字或字母验证码。通过强制用户和应用进行交互。来有效地遏制CSRF攻击。")]),t._v(" "),_("h3",[t._v("Referer Check")]),t._v(" "),_("p",[t._v("检查假设是非正常页面过来的请求，则极有可能是CSRF攻击。")]),t._v(" "),_("h3",[t._v("token验证")]),t._v(" "),_("p",[t._v("\n      在 HTTP 请求中以參数的形式添加一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，假设请求中没有 token 或者 token 内容不对，则觉得可能是 CSRF 攻击而拒绝该请求。"),_("br"),t._v("\n      token必须随机\n    ")]),t._v(" "),_("h4",[t._v("关于web跨域Post使用token思路")]),t._v(" "),_("p",[t._v("\n      移动端登录时，服务端验证表单信息。登录成功，生成token，返回给client"),_("br"),t._v("\n      client将token存在localstorage/sessionstorage中，每次提交表单，必须要携带token"),_("br"),t._v("\n      服务端获取请求，如果没有token忽略请求\n    ")]),t._v(" "),_("h3",[t._v("在HTTP头中自己定义属性并验证")]),t._v(" "),_("p",[t._v("这样的方法也是使用 token 并进行验证。这里并非把 token 以參数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自己    定义的属性里。通过 XMLHttpRequest 这个类，能够一次性给全部该类请求加上 csrftoken 这个 HTTP 头属性。并把 token 值放入当中。这样攻克了上种方法在请求中添加 token 的不便。同一时候，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用操心 token 会透过 Referer 泄露到其它站点中去")])])])}]};var n=v("VU/8")({name:"CSRF"},_,!1,function(t){v("VSGQ")},"data-v-d7547bb4",null);e.default=n.exports},VSGQ:function(t,e){},yZa2:function(t,e,v){t.exports=v.p+"static/img/CSRF.f353583.jpg"}});
//# sourceMappingURL=9.222c91a876c1e61db015.js.map